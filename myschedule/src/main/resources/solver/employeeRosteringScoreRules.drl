package solver;
    dialect "java"
import com.example.domain.zuoxi.bean.Shift
import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScoreHolder
import java.time.temporal.ChronoUnit
import java.time.Duration
import com.example.domain.zuoxi.bean.Employee
import com.example.domain.zuoxi.bean.EmployeeAvailability
import com.example.enums.AvailabilityType
import com.example.domain.zuoxi.bean.GroupPlan
import java.time.temporal.TemporalAdjusters;
global HardSoftScoreHolder scoreHolder;

rule "one employee can not work in the same day"
when
    $s : Shift(
                employeeId != null,
                $employeeId: employeeId,
                $startDate: startTime.toLocalDate(),
                $id:id)
    Shift(
            employeeId == $employeeId,
            $startDate == startTime.toLocalDate(),
            id>$id)
then
    scoreHolder.penalize(kcontext);
    //scoreHolder.addHardConstraintMatch(kcontext,-11);
    //System.out.println("one employee can not work in same day");
 end

rule "Break between non-consecutive shifts is at least 12 hours"
when
    $s : Shift(
            employeeId != null,
            $employeeId : employeeId,
            $leftEndDateTime: endTime)
    Shift(
            employeeId == $employeeId,
            $leftEndDateTime <= endTime,
            $leftEndDateTime.until(startTime, ChronoUnit.HOURS) < 12,
            this!=$s)
then
    //scoreHolder.addHardConstraintMatch(kcontext,-7);
    scoreHolder.penalize(kcontext);
    //System.out.println("Break between non-consecutive shifts is at least 12 hours");
end

rule "at most work 22 days"
    when
        Employee($id:id)
        //$s : Shift(employeeId == $id, $startDateTime : date)
        Number($shiftCount:intValue > 22) from accumulate(
            $other : Shift(
                employeeId == $id//, $shiftStart : date,
                //$shiftEnd : endTime
            ),
            count($other)
            //$totalMinutes : sum(Duration.between($shiftStart, $shiftEnd).toMinutes())
        )
    then
        System.out.println($shiftCount);
        scoreHolder.penalize(kcontext);
end

rule "Unavailable time slot for an employee"
    when
        $availability: EmployeeAvailability(
                state == AvailabilityType.UNAVAILABLE.getType(),
                $employeeId : employeeId,
                $startDateTime : startDateTime,
                $endDateTime : endDateTime)
        Shift(employeeId == $employeeId,
            $startDateTime <= endTime,
            $endDateTime >= startTime)
    then
        scoreHolder.penalize(kcontext);
end

rule "Desired time slot for an employee"
    when
        $availability: EmployeeAvailability(
                state == AvailabilityType.DESIRED.getType(),
                $employeeId : employeeId,
                $startDateTime : startDateTime,
                $endDateTime : endDateTime)
        Shift(employeeId == $employeeId,
            $startDateTime <= endTime,
            $endDateTime >= startTime)
    then
        scoreHolder.reward(kcontext);
end

rule "Undesired time slot for an employee"
    when
        $availability: EmployeeAvailability(
                state == AvailabilityType.UNDESIRED.getType(),
                $employeeId : employeeId,
                $startDateTime : startDateTime,
                $endDateTime : endDateTime)
        Shift(employeeId == $employeeId,
            $startDateTime <= endTime,
            $endDateTime >= startTime)
    then
        scoreHolder.penalize(kcontext);
end

rule "No more than 3 consecutive shifts"
    when
        Shift(
                $employeeId : employeeId,
                $firstStartDate : startTime.toLocalDate())
        Shift(
                employeeId == $employeeId,
                $firstStartDate.plusDays(1) == startTime.toLocalDate(),
                $secondStartDate : startTime.toLocalDate())
        Shift(
                employeeId == $employeeId,
                $secondStartDate.plusDays(1) == startTime.toLocalDate()
                )
    then
        scoreHolder.penalize(kcontext);
end
//与指定每天班组指定的班类型不一致
rule "shift type error"
    when
        Employee($id:id,$groupId:groupId)
        Shift(employeeId==$id,$shiftName:shiftName,$date:date)
        GroupPlan(groupId==$groupId,date==$date,!$shiftName.startsWith(shiftType))
    then
        scoreHolder.penalize(kcontext);
end

rule "same team need same shift in one day"
    when
        Employee($id:id,$groupId:groupId)
        Employee(id>$id,$id1:id,$groupId==groupId)
        $s:Shift(employeeId==$id,$shiftName:shiftName,$date:date)
        Shift(employeeId==$id1,$shiftName!=shiftName,$date==date)
    then
        System.out.println($id+":"+$id1);
        scoreHolder.penalize(kcontext);
end

rule "overnight need rest for 2 days"
    when
        $s:Shift($employeeId:employeeId,shiftName.startsWith("F"),$date:date) &&
        (exists Shift(employeeId==$employeeId,$date==date.minusDays(1))||exists Shift(employeeId==$employeeId,$date==date.minusDays(2)))
    then
        System.out.println($employeeId+":"+$date);
        scoreHolder.penalize(kcontext);
end
rule "no rest work rest"
    when
        $s:Shift($employeeId:employeeId,$date:date,date!=date.with(TemporalAdjusters.lastDayOfMonth()),date.getDayOfMonth()!=1)
        not(Shift(employeeId==$employeeId,$date==date.minusDays(1)))
        not(Shift(employeeId==$employeeId,$date==date.plusDays(1)))
    then
        System.out.println($employeeId+":"+$date+"665");
        scoreHolder.penalize(kcontext);
end
rule "test forall"
    when
        exists(Employee())
        forall(Shift(employeeId in (1,3)))
    then
        System.out.println("员工所有都是1或3");
end
rule "test1"
    //activation-group "g1"
    when
        Shift(id>1&&<5,$id:id)
    then
        System.out.println("11111:"+$id);
end
rule "test2"
activation-group "g1"
salience 4
    when
    then
        System.out.println("22222");
end
rule "test3"
activation-group "g1"
salience 3
    when
    then
        System.out.println("33333");
end
/*
when
        exists(Employee())
        forall(Shift(employeeId in (1,3)))
    then
*/



